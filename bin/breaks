#!/usr/bin/env fish

# The time allowed spent working, in seconds.
set work_time (math '20 * 60')

# The amount of one minute sleep intervals in a work cycle.
set sleep_intervals (math "$work_time / 60")

# The number of short breaks in an hour, after which a long break should be
# enforced.
set short_break_count (math "3600 / $work_time")

# The short break time, in seconds.
set short_break_time 30

# The long break time, in seconds.
set long_break_time 300

# The time to wait (in seconds) after sending a notification and enforcing
# a break.
set heads_up_time 10

# The number of breaks processed so far.
set breaks 0

# The title to use for break reminder notifications.
set notify_title 'Break reminder'

# The message to display when taking a long break.
set long_break_message 'Get up, drink some water, rotate your shoulders'

# The last short break message that was generated.
set last_short_break_message ''

# The path to the script directory
set project_dir (dirname (dirname (realpath (status --current-filename))))

# The sound to play before starting a break.
set start_sound "$project_dir/audio/start_break.wav"

# The sound to play after starting a break.
set stop_sound "$project_dir/audio/stop_break.wav"

function is_locked
    set output (cinnamon-screensaver-command -q)

    if test $status -eq 1
        echo 'Failed to obtain the Cinnamon screensaver status'
        exit 1
    end

    string match -r -q 'is active' $output
end

function timestamp
    date +%s
end

function random_short_break_message
    set message (shuf -n1 "$project_dir/messages/short.txt")

    while test $message = $last_short_break_message
        set message (shuf -n1 "$project_dir/messages/short.txt")
    end

    set last_short_break_message $message
    echo $message
end

while true
    set slept 0
    set start_ticking (timestamp)

    while test $slept -lt $sleep_intervals
        sleep 60

        if is_locked
            set slept 0
            set start_ticking (timestamp)
        else
            set slept (math "$slept + 1")
        end
    end

    set stop_ticking (timestamp)

    # If the computer is suspended during ticking, we don't want to enforce
    # a break e.g. 10 minutes after waking up. To handle this, we start ticking
    # again if it took too long to complete a work cycle.
    if test (math "$stop_ticking - $start_ticking") -gt (math "$work_time * 2")
        echo 'The computer was likely suspended, restarting the timer'
        set breaks 0
        continue
    end

    # Outside working hours we don't enforce breaks, as I'm moving around
    # anyway.
    set hour (date +'%H')

    if test $hour -ge 18 -o $hour -le 10
        echo 'Not enforcing a break outside working hours'

        # Reset the breaks counter so that we start from scratch at the start of
        # the day.
        set breaks 0
        continue
    end

    # If Zoom is running, don't enforce breaks. After Zoom no longer runs, we
    # force a break.
    while pgrep ZoomLauncher >/dev/null
        echo 'Waiting for Zoom to close before enforcing a break'
        sleep 60
    end

    if is_locked
        echo 'Screensaver is active, waiting for the screen to be unlocked'

        # Wait for the screen to be unlocked, after which we will start a new
        # work cycle. We don't immediately start a new cycle, as this may result
        # in a break being enforced a few minutes after unlocking the screen
        # (depending on how long the screen was locked for).
        while is_locked
            sleep 30
        end

        continue
    end

    # A long break is scheduled every N short breaks, based on the duration of
    # the short breaks.
    if test $breaks -gt 0 && test (math "$breaks % $short_break_count") -eq 0
        set long_break true
    else
        set long_break false
    end

    if test $long_break = true
        set heads_up_message 'Long break coming up'
        set lock_message $long_break_message
        set break_time $long_break_time
    else
        set heads_up_message 'Short break coming up'
        set lock_message (random_short_break_message)
        set break_time $short_break_time
    end

    echo $heads_up_message

    notify-send -u normal -i media-playback-pause \
        "$notify_title" "$heads_up_message"

    # Break starts
    aplay $start_sound >/dev/null 2>&1
    sleep $heads_up_time

    # Pause any playing media
    set playing_media (playerctl metadata -f '{{playerName}} {{status}}' | \
        rg -o '(\w+) Playing' -r '$1')

    for player in $playing_media
        # The timeout is needed because of the following bugs:
        #
        # * https://github.com/altdesktop/playerctl/issues/187
        # * https://bugzilla.mozilla.org/show_bug.cgi?id=1648874
        timeout 0.5 playerctl -p $player pause
    end

    # We unlock first so we display the lock message, even when the screen was
    # already locked.
    cinnamon-screensaver-command -d
    cinnamon-screensaver-command -l -m "$lock_message"

    sleep $break_time

    # Break is over
    cinnamon-screensaver-command -d
    aplay $stop_sound >/dev/null 2>&1

    # Resume any paused media
    for player in $playing_media
        timeout 0.5 playerctl -p $player play
    end

    set breaks (math "$breaks + 1")

    echo 'Break is over, time for work'
end
